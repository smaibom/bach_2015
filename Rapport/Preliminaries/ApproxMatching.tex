  \subsubsection{Pattern Matching}
   A pattern is a rule that a potential match must adhere to for it to be a 
   correct match. When matching is done using a pattern, then a pattern match 
   is being performed. Matching with regular expressions is pattern matching, 
   since regular expressions are patterns.\\
   Pattern matching performs its matches in different ways depending on the 
   pattern used; regular expressions uses automata to match, whereas 
   mathematica organizes its patterns as a tree structure which is then searched 
   through. The two examples fits different needs, as the tree structure 
   form of mathematica allows a guaranteed worst case running time of 
   $O(n)$, where n is the depth of the tree, while automata allows transitions 
   to previously-traversed states.
  \subsubsection{Approximate Matching}
   Approximate matching is an extension to other types of matching, where errors 
   are allowed in the text that's being searched through. An error is defined as 
   follows;
   \begin{mydef}\centering
    An error is when an encountered character in a string is different from 
    what is expected. An error can manifest itself in three different ways:
    \begin{enumerate}
    \item A mismatch, where a character is transformed into a different character
    \item A deletion, where a character is missing, and
    \item An insertion, where a random character has been inserted in the text
    \end{enumerate}
   \end{mydef}
   \begin{myex}\centering
    Say we want to match the text {\tt ABC}, and we want to allow for a 
    maximum of three errors. Then the following four text strings will match 
    {\tt ABC}
    \begin{align*}
    {\tt ABXC}&~\text{One insertion}\\
    {\tt BC}&~\text{One deletion}\\
    {\tt ABX}&~\text{One mismatch}\\
    {\tt BXA}&~\text{One insertion, one deletion and one mismatch}
    \end{align*}
   \end{myex}
   \begin{comment}
   While it is possible to perform approximate matching with regular expressions, it is not 
   a computationally efficient thing to do unless it is done on a regex-engine 
   that natively supports approximate matching. This is because the complexity 
   and size of a regular expression increases dramatically when mismatches and 
   insertions are hardcoded for regex, as shown by example \ref{exInsert}
   \begin{myex}\label{exInsert}
   Let {\tt ABCD} be a pattern that we wish to search a text for, where we 
   allow for one insertion. Then the resulting regular expression will be \\
   \begin{center}
   {\tt .ABCD$|$A.BCD$|$AB.CD$|$ABC.D$|$ABCD.$|$ABCD}
   \end{center}
   \end{myex}
   Allowing one insertion in our 4-character text results in six possible 
   permutations that must be accounted for, and the blowup of the regular 
   expression's size only increases as we try to match longer strings with more 
   insertions.
   \end{comment}
