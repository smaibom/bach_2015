\section{Our Implementation}
Having defined an algorithm in Section~\ref{sec:tnfa}, we wished to construct a simple program based on TNFA, which would pattern-match data allowing for mismatches.

When wrote a simple program in C++ which we named TNFA Pattern-Matcher (TPaMa). TPaMa is able to create a TNFA from a RE, and it supports a series of RE symbols, including $+, ^*, |, ?$ along with concatenation of characters. An example of a TFNA from a RE could be RE "(GAT)+" which would produce a structure as shown in Figure~\ref{fig:gat}

\begin{figure}[h!]
\centering
\includegraphics[width=0.5\textwidth]{lib/gat.png}
\caption{Example of how TPaMa constructs a TNFA from RE (GAT)+}
\label{fig:gat}
\end{figure}

However, currently the search implementation of TPaMa only support simple patterns such as "GAT" which does not cause any $\epsilon$-transitions to be constructed, this choice was made so we could focus on the performance of mismatching while giving support to the most crucial part of pattern-matching.

This also meant that determining reachable states, as mentioned in Algorithm~\ref{tnfasim} \&~\ref{tnfatrans} is rather straightforward, as there's only up to one possible next state for every state (zero for the final state).

To handle mismatching, recall Table~\ref{nfac}:

%\begin{table}[h]
\begin{tabular}{*{2}{m{0.4\textwidth}}}
\begin{center}$a$\end{center} &\begin{center}
\begin{tikzpicture}[->,>=stealth,shorten >=1pt,auto,node distance=2 cm, scale = 0.75, transform shape,initial text={}]
  \node [initial, state] (0) {};
  \node [accepting,state, right of=0] (1) {};

  \path[->] (0) edge node [above] {$a$} (1);
  \path[->] (0) edge [color=green, in=100,out=80,loop] node [color=black, above] {$\epsilon/i$} (0);
  \path[->] (0) edge [color=red,bend left] node [color=black, above] {$\epsilon/d$} (1);

  \path[->] (0) edge [color=blue,bend right] node [color=black, below] {$\epsilon/a$} (1);
\end{tikzpicture}\end{center}\\
\end{tabular}
%\end{table}

There's three different types of mismatches. Instead of having three types of transitions we simulate this by having three counters in each state, one for each type of mismatch (insertions, alternation and deletion), keeping track of the remaining number of mismatches allowed in the match. Whenever a match can not be made, for each mismatch counter with a positive value, a new state is created.


\begin{lstlisting}[language=C++]
if((*it).insertions > 0){
    add_state(it, (*it).node, (*it).path+1, (*it).insertions-1, (*it).deletions, 
        (*it).mutations);
    ++it;
}
if((*it).mutations > 0){
    add_state(it, (*it).node->next, (*it).path+1, (*it).insertions, (*it).deletions,
        (*it).mutations-1);
    ++it;
}
 if((*it).deletions > 0){
    add_state(it, (*it).node->next, (*it).path, (*it).insertions, (*it).deletions-1,
        (*it).mutations);
    ++it;
}
\end{lstlisting}

