%a previously found match (backreferencing)
%a modified pattern (reverse, complementary)
\section{TRE}\label{tre}
Recall that in section~\ref{probanal}, we determined that the challenge of our 
solution would lie in matching
\begin{enumerate}
\item \label{err} with errors allowed,
\item \label{backr} a previously found match, and 
\item \label{rev} a modified pattern.
\end{enumerate}
An implementation based on TRE would address two of the three previously mentioned 
problems. Item~\ref{err} would require approximate matching support, and 
TRE fully supports approximate matching. Item~\ref{backr} could be resolved 
with backreferences (even if backreferences are computationally inefficient) 
and TRE also supports this. Item~\ref{rev} means that sometimes we want to 
match a modification of a pattern found previously - like the reverse 
complement of a pattern. This would have to be implemented in TRE's parser 
(to denote a symbol for the modified patterns, e.g. the reverse or the 
complement of a pattern) as 
well as in TRE's basic functionality.\\
When analysing TRE to see how it worked so we could start modifying the 
program, we discovered that TRE would define every newline as a delimiter. The 
delimiter specifies how the data should be broken up, so for every new line 
the current line would be loaded into the buffer and be processed. This in 
itself would not be a problem if not because TRE would discard any match that 
was currently being processed when it reached a delimiter, causing matches that 
wrapped around two lines to be discarded. The fix to this was easy to make 
however; if a wrapper was created which would feed the text data to TRE, 
ignoring all newlines, then TRE would load the entire file into its buffer 
and would no longer cause it to discard potential matches that continued to 
the next line.\\
When we then tried to run a file through TRE which had no newlines, we discovered 
another feature of TRE which would not work for our project; TRE would only 
match one match per delimiter - the earliest, best-matching match (where a 
best-matching match is a match with the least amount of errors). Since we had 
to trim the text files for TRE so there were no newlines, TRE would only 
return one match. TRE was built around this feature, which has lead to the following 
design choices;
\begin{itemize}
\item the program runs through the data once to deetermine how many errors the 
best-matching match has, and then runs through the text file again, stopping 
when the best-matching match has been found, 
\item TRE ignores any matches that are not best-matching, meaning there's 
no way for TRE to identify and output acceptable matches.
\end{itemize}
This coupled with little documentation of how the code works meant that it would 
take a long time to properly analyse TRE in order to find out how we could 
modify it to suit our project. At this point we decided that creating our 
own solution would be less time-consuming, while also allowing us to design our 
solution ourselves.





  
For our implementation of scan\_for\_matches patterns in TRE, we needed to 
first make a brief analysis of the program to see what it could and couldn't 
do. What we discovered after our initial tests was that TRE defined each 
new line as a delimiter (a delimiter defines at which points the text will be 
separated, so each chunk can be evaluated individually). 
This caused a small, but surmountable, problem; chromosome data 
should be read as one continous line that spans over many lines. Since TRE 
split the data up per line, if a match spanned over more than one line, it 
wouldn't find it. To this problem there was an easy fix; we would make a small 
wrapper which would feed the text file to TRE, removing any newlines as they 
occurred.\\
With this problem solved, we did a trial test to check the accuracy and 
running time of TRE. Here we encountered a second, greater problem; TRE 
would find only one match per delimiter (the first longest match with fewest 
errors, prioritizing exact matches). This was a harder problem to fix, because this feature was 
deeply entrenched in the code, and everything had seemingly been designed 
around this feature. The searching tool that TRE uses, agrep, only receives 
the best match that the other tools of TRE has found, but throughout TRE's 
code, it won't save the matches it has found, but instead repeatedly discard old 
matches. The problem is compounded by the fact that TRE will immediately stop searching the 
text if it finds an exact match, leaving behind potential matches. In light of 
these problems, we decided that attempting to fully understand TRE's design and 
subsequently heavily modding it in order for it to return all matches would 
take too long, and that we would instead create our own solution.
